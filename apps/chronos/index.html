<!DOCTYPE html>
<html lang="zh-CN" class="sl-theme-dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronos | Ouroboros Work Log</title>
    <link rel="icon" href="../shared/logo.png" type="image/png">

    <!-- 1. Ouroboros Kernel (Skin) -->
    <link rel="stylesheet" href="../shared/ods.css">

    <!-- 2. UI Frameworks -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/themes/dark.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Outfit:wght@300;500;800&display=swap"
        rel="stylesheet">

    <!-- 3. Framework Logic -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script type="module"
        src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/shoelace-autoloader.js"></script>

    <!-- 4. Ouroboros Kernel (Brain) -->
    <script src="../shared/satellite.js"></script>

    <style>
        /* App Specific Styles */
        sl-input::part(base) {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }

        sl-input::part(input) {
            color: white;
        }

        sl-tab-group::part(tabs) {
            border-bottom-color: rgba(255, 255, 255, 0.05);
        }

        sl-tab::part(base) {
            color: #64748b;
            font-weight: 600;
            font-family: var(--ods-font-display);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.75rem;
        }

        sl-tab[active]::part(base) {
            color: white;
        }

        .timer-ring {
            stroke-dasharray: 283;
            stroke-dashoffset: 283;
            transition: stroke-dashoffset 1s linear;
        }
    </style>
</head>

<body x-data="app()" class="ready">
    <nav
        class="p-6 flex justify-between items-center border-b border-white/5 sticky top-0 bg-[#020617]/80 backdrop-blur-md z-50">
        <a href="../../index.html" class="text-slate-400 hover:text-white transition-colors flex items-center gap-2">
            <sl-icon name="arrow-left"></sl-icon>
            Portal
        </a>
        <div class="flex items-center gap-4">
            <template x-if="dbState === 'loading'"><sl-badge variant="warning" pill
                    pulse>Syncing...</sl-badge></template>
            <template x-if="dbState === 'offline'"><sl-badge variant="neutral" pill>Offline</sl-badge></template>
            <template x-if="dbState === 'online'"><sl-badge variant="success" pill>Cloud Active</sl-badge></template>
            <div class="flex items-center gap-2">
                <img src="../shared/logo.png" class="w-8 h-8" alt="Logo">
                <h2 class="text-xl font-black gradient-text tracking-tighter uppercase">Chronos</h2>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto p-6 grid grid-cols-1 lg:grid-cols-12 gap-8">

        <!-- Left Column: Tasks & History -->
        <div class="lg:col-span-8 space-y-8">

            <!-- Task Creation -->
            <section class="glass-card p-6">
                <div class="flex gap-4">
                    <sl-input class="flex-1" placeholder="有什么新计划？" :value="newTaskTitle"
                        @sl-input="newTaskTitle = $event.target.value" @keydown.enter="addTask" clearable>
                        <sl-icon name="list-task" slot="prefix"></sl-icon>
                    </sl-input>
                    <sl-button variant="primary" @click="addTask" :loading="isAddingTask">添加任务</sl-button>
                </div>
            </section>

            <!-- Navigation Tabs -->
            <sl-tab-group @sl-tab-show="activeTab = $event.detail.name">
                <sl-tab slot="nav" panel="tasks" active>任务列表</sl-tab>
                <sl-tab slot="nav" panel="logs">时间日志</sl-tab>
                <sl-tab slot="nav" panel="summary">每日回顾</sl-tab>
            </sl-tab-group>

            <!-- Task List Content -->
            <div x-show="activeTab === 'tasks'" class="space-y-4" x-transition>
                <template x-if="tasks.length === 0">
                    <div class="p-12 text-center text-slate-600 font-light italic">暂无任务，开启一个新的开始。</div>
                </template>
                <template x-for="task in sortedTasks" :key="task.id">
                    <div class="glass-card p-5 flex items-center justify-between group"
                        :class="task.is_completed ? 'opacity-50' : ''">
                        <div class="flex items-center gap-4 flex-1">
                            <button @click="toggleTaskStatus(task)"
                                class="w-6 h-6 rounded-full border-2 border-indigo-500/50 flex items-center justify-center transition-all"
                                :class="task.is_completed ? 'bg-indigo-500 border-indigo-500' : 'hover:border-indigo-400'">
                                <sl-icon x-show="task.is_completed" name="check" class="text-white text-xs"></sl-icon>
                            </button>
                            <span x-text="task.title" :class="task.is_completed ? 'line-through text-slate-500' : ''"
                                class="text-lg font-medium"></span>
                        </div>
                        <div class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <sl-icon-button name="play-fill" label="Start Task" class="text-xl text-indigo-400"
                                @click="selectTask(task)" x-show="!task.is_completed"></sl-icon-button>
                            <sl-icon-button name="trash" label="Delete Task" class="text-xl text-red-400"
                                @click="deleteTask(task.id)"></sl-icon-button>
                        </div>
                    </div>
                </template>

                <!-- Load More Button -->
                <template x-if="hasMoreTasks">
                    <div class="text-center pt-4">
                        <sl-button variant="text" @click="loadMoreTasks" :loading="isLoadingTasks">
                            <sl-icon slot="prefix" name="arrow-down-circle"></sl-icon>
                            加载更多任务
                        </sl-button>
                    </div>
                </template>
            </div>

            <!-- Logs Board Content -->
            <div x-show="activeTab === 'logs'" class="space-y-6" x-transition>
                <div class="flex items-center justify-between mb-4">
                    <sl-input type="date" :value="filterDate" @sl-input="filterDate = $event.target.value" size="small"
                        class="w-40"></sl-input>
                    <sl-badge variant="neutral" x-text="'Total: ' + formatTime(totalDaySeconds)"></sl-badge>
                </div>
                <div class="space-y-2">
                    <template x-for="log in filteredLogs" :key="log.id">
                        <div class="glass-card p-4 flex items-center justify-between border-l-4"
                            :style="'border-left-color: ' + (log.task_id ? 'var(--ods-primary)' : '#475569')">
                            <div>
                                <div class="flex items-center gap-4">
                                    <sl-badge variant="neutral" x-text="getTimeRange(log)" size="small"></sl-badge>
                                    <span class="font-bold tracking-tight" x-text="log.activity"></span>
                                </div>
                                <div class="text-sm text-slate-400 mt-2 flex items-center gap-2">
                                    <sl-icon name="clock"></sl-icon>
                                    <span x-text="formatTime(log.duration)"></span>
                                </div>
                            </div>
                            <sl-icon-button name="trash" @click="deleteLog(log.id)"
                                class="text-red-400/50 hover:text-red-400"></sl-icon-button>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Daily Summary Content -->
            <div x-show="activeTab === 'summary'" class="space-y-8" x-transition>
                <template x-for="day in dailyHistory" :key="day.date">
                    <div class="space-y-3">
                        <div class="flex items-center gap-3">
                            <h3 class="text-xs font-black uppercase tracking-widest text-indigo-400"
                                x-text="day.date === new Date().toISOString().split('T')[0] ? '今天 · ' + day.date : day.date">
                            </h3>
                            <div class="h-px flex-1 bg-white/5"></div>
                        </div>
                        <div class="flex flex-wrap gap-2">
                            <template x-for="task in day.tasks" :key="task">
                                <div
                                    class="glass-card px-4 py-2 text-sm font-medium hover:border-indigo-500/50 transition-colors">
                                    <span x-text="task"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>

                <!-- Load More Logs Button -->
                <template x-if="hasMoreLogs">
                    <div class="text-center pt-4">
                        <sl-button variant="text" @click="loadMoreLogs" :loading="isLoadingLogs">
                            <sl-icon slot="prefix" name="clock-history"></sl-icon>
                            加载更多历史
                        </sl-button>
                    </div>
                </template>
            </div>
        </div>

        <!-- Right Column: Active Pulse -->
        <div class="lg:col-span-4 space-y-8">
            <section class="glass-card p-8 sticky top-24 text-center">
                <h3 class="text-xs font-black uppercase tracking-[0.2em] text-indigo-400 mb-8">Active Pulse</h3>

                <div class="relative inline-flex items-center justify-center mb-8">
                    <!-- Timer Circle -->
                    <svg class="w-48 h-48 -rotate-90">
                        <circle cx="96" cy="96" r="80" stroke="currentColor" stroke-width="4" fill="transparent"
                            class="text-slate-800" />
                        <circle cx="96" cy="96" r="80" stroke="currentColor" stroke-width="6" fill="transparent"
                            class="text-indigo-500 transition-all duration-1000"
                            :style="'stroke-dasharray: 502; stroke-dashoffset: ' + (502 - (timerSeconds % 60) * (502/60))" />
                    </svg>
                    <div class="absolute flex flex-col items-center">
                        <span class="text-4xl font-black tabular-nums tracking-tighter"
                            x-text="formatTime(timerSeconds)"></span>
                        <sl-badge pill variant="neutral" class="mt-2"
                            x-text="isRunning ? 'Running' : 'Paused'"></sl-badge>
                    </div>
                </div>

                <div class="space-y-4">
                    <div
                        class="p-4 bg-white/5 rounded-2xl min-h-[80px] flex flex-col justify-center border border-white/5">
                        <template x-if="!selectedTask">
                            <span class="text-slate-500 italic text-sm">选择一个任务开始计时</span>
                        </template>
                        <template x-if="selectedTask">
                            <div>
                                <sl-badge variant="primary" class="mb-2 uppercase tracking-widest text-[10px]">Thinking
                                    about</sl-badge>
                                <span class="text-lg font-bold block" x-text="selectedTask.title"></span>
                            </div>
                        </template>
                    </div>

                    <div class="flex gap-2">
                        <sl-button variant="default" class="flex-1" @click="toggleTimer" :disabled="!selectedTask">
                            <sl-icon slot="prefix" :name="isRunning ? 'pause-fill' : 'play-fill'"></sl-icon>
                            <span x-text="isRunning ? 'Pause' : 'Start'"></span>
                        </sl-button>
                        <sl-button variant="danger" outline @click="stopTimer"
                            :disabled="!isRunning && timerSeconds === 0">
                            <sl-icon slot="prefix" name="stop-fill"></sl-icon>
                            Stop
                        </sl-button>
                    </div>
                </div>
            </section>
        </div>

    </main>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('app', () => ({
                ...Satellite({
                    title: 'Chronos | Ouroboros Work Log',
                    async init() {
                        if (window.sbClient) {
                            await this.syncData();
                        } else {
                            this.dbState = 'offline';
                        }
                        // 启动恢复逻辑：检查是否有未完成的“心跳”
                        this.recoverLastSession();

                        window.addEventListener('beforeunload', () => {
                            if (this.isRunning) this.persistTimerState();
                        });
                    }
                }),

                activeTab: 'tasks',

                // Tasks State
                tasks: [],
                newTaskTitle: '',
                selectedTask: null,
                isAddingTask: false,
                taskPageSize: 20,
                taskCurrentPage: 1,
                hasMoreTasks: false,
                isLoadingTasks: false,

                // Logs State
                logs: [],
                logsCurrentPage: 1,
                logsPageSize: 50,
                hasMoreLogs: false,
                isLoadingLogs: false,
                filterDate: new Date().toISOString().split('T')[0],

                // Timer State
                timerSeconds: 0,
                accumulatedSeconds: 0, // 累计已完成秒数
                isRunning: false,
                timerInterval: null,
                sessionStartAt: null,

                async init() {
                    if (window.sbClient) {
                        await this.syncData();
                    }
                    // 启动恢复逻辑：检查是否有未完成的“心跳”
                    this.recoverLastSession();

                    window.addEventListener('beforeunload', () => {
                        if (this.isRunning) this.persistTimerState();
                    });

                    // 监听页面可见性变化，确保切回来时计时器立即更新
                    document.addEventListener('visibilitychange', () => {
                        if (!document.hidden && this.isRunning) {
                            this.refreshTimer();
                        }
                    });

                    console.log('Chronos Initialized');
                },

                // 强制刷新当前计时器显示的秒数
                refreshTimer() {
                    if (this.isRunning && this.sessionStartAt) {
                        const now = new Date();
                        const elapsed = Math.floor((now - this.sessionStartAt) / 1000);
                        this.timerSeconds = this.accumulatedSeconds + elapsed;
                    }
                },

                // Pulse Sync: 记录当前计时状态至本地“黑匣子”
                persistTimerState() {
                    if (this.isRunning && this.selectedTask) {
                        localStorage.setItem('chronos_active_session', JSON.stringify({
                            task: this.selectedTask,
                            accumulatedSeconds: this.accumulatedSeconds,
                            startAt: this.sessionStartAt.toISOString(),
                            lastTick: new Date().toISOString()
                        }));
                    } else {
                        localStorage.removeItem('chronos_active_session');
                    }
                },

                async recoverLastSession() {
                    const raw = localStorage.getItem('chronos_active_session');
                    if (!raw) return;

                    try {
                        const session = JSON.parse(raw);
                        const lastTick = new Date(session.lastTick);
                        const startAt = new Date(session.startAt);
                        const now = new Date();

                        // 如果最后一次心跳距今超过 10 秒，视为中断，进行打捞
                        if (now - lastTick > 10000) {
                            const duration = (session.accumulatedSeconds || 0) + Math.floor((lastTick - startAt) / 1000);
                            if (duration > 5) { // 忽略太短的无意义记录
                                const recoveredLog = {
                                    task_id: session.task.id,
                                    activity: session.task.title + ' (已恢复)',
                                    duration: duration,
                                    started_at: session.startAt,
                                    ended_at: session.lastTick
                                };

                                if (window.sbClient) {
                                    await window.sbClient.from('chronos_logs').insert([recoveredLog]);
                                    await this.syncData();
                                } else {
                                    this.logs.unshift({ ...recoveredLog, id: Date.now() });
                                }
                                alert(`检测到意外中断，已自动为你恢复并保存了上次 ${this.formatTime(duration)} 的工作日志。`);
                            }
                            localStorage.removeItem('chronos_active_session');
                        } else {
                            // 如果中断时间很短（比如刚刷新），可以尝试继续计时
                            this.selectedTask = session.task;
                            this.sessionStartAt = startAt;
                            this.accumulatedSeconds = session.accumulatedSeconds || 0;
                            this.refreshTimer();
                            this.toggleTimer();
                        }
                    } catch (e) {
                        localStorage.removeItem('chronos_active_session');
                    }
                },

                async syncData() {
                    this.dbState = 'loading';
                    try {
                        this.tasks = []; // Reset locally to avoid dups on full re-sync
                        this.logs = [];
                        this.taskCurrentPage = 1;
                        this.logsCurrentPage = 1;

                        await Promise.all([
                            this.fetchTasks(),
                            this.fetchLogs()
                        ]);

                        this.dbState = 'online';
                    } catch (e) {
                        console.error(e);
                        this.dbState = 'offline';
                    }
                },

                async fetchTasks() {
                    this.isLoadingTasks = true;
                    try {
                        const start = (this.taskCurrentPage - 1) * this.taskPageSize;
                        const end = start + this.taskPageSize - 1;

                        let { data: ts, error } = await window.sbClient
                            .from('chronos_tasks')
                            .select('*')
                            .order('created_at', { ascending: false })
                            .range(start, end);

                        if (error) throw error;

                        if (ts && ts.length > 0) {
                            // Append new tasks, checking for duplicates just in case
                            const existingIds = new Set(this.tasks.map(t => t.id));
                            const newItems = ts.filter(t => !existingIds.has(t.id));
                            this.tasks = [...this.tasks, ...newItems];
                        }

                        // Determine if there are more tasks
                        this.hasMoreTasks = ts && ts.length === this.taskPageSize;

                    } catch (e) {
                        console.error("Error fetching tasks:", e);
                    } finally {
                        this.isLoadingTasks = false;
                    }
                },

                async fetchLogs() {
                    this.isLoadingLogs = true;
                    try {
                        const start = (this.logsCurrentPage - 1) * this.logsPageSize;
                        const end = start + this.logsPageSize - 1;

                        let { data: ls, error } = await window.sbClient
                            .from('chronos_logs')
                            .select('*')
                            .order('started_at', { ascending: false })
                            .range(start, end);

                        if (error) throw error;

                        if (ls && ls.length > 0) {
                            const existingIds = new Set(this.logs.map(l => l.id));
                            const newItems = ls.filter(l => !existingIds.has(l.id));
                            this.logs = [...this.logs, ...newItems];
                        }

                        this.hasMoreLogs = ls && ls.length === this.logsPageSize;
                    } catch (e) {
                        console.error("Error fetching logs:", e);
                    } finally {
                        this.isLoadingLogs = false;
                    }
                },

                // Task Methods
                get sortedTasks() {
                    return this.tasks.slice().sort((a, b) => a.is_completed - b.is_completed);
                },

                // get paginatedTasks() {
                //     return this.sortedTasks.slice(0, this.taskCurrentPage * this.taskPageSize);
                // },

                // get hasMoreTasks() {
                //     return this.paginatedTasks.length < this.sortedTasks.length;
                // },

                loadMoreTasks() {
                    this.taskCurrentPage++;
                    this.fetchTasks();
                },

                loadMoreLogs() {
                    this.logsCurrentPage++;
                    this.fetchLogs();
                },

                async addTask() {
                    if (!this.newTaskTitle.trim()) return;
                    this.isAddingTask = true;

                    try {
                        const newTask = { title: this.newTaskTitle, is_completed: false };

                        if (window.sbClient) {
                            const { data, error } = await window.sbClient.from('chronos_tasks').insert([newTask]).select();
                            if (data) this.tasks.unshift(data[0]);
                        } else {
                            // Simulate network delay for offline mode if needed, or just instant
                            this.tasks.unshift({ ...newTask, id: Date.now() });
                        }
                        this.newTaskTitle = '';
                    } finally {
                        this.isAddingTask = false;
                    }
                },

                async deleteTask(id) {
                    if (window.sbClient) await window.sbClient.from('chronos_tasks').delete().eq('id', id);
                    this.tasks = this.tasks.filter(t => t.id !== id);
                    if (this.selectedTask && this.selectedTask.id === id) this.stopTimer();
                },

                async toggleTaskStatus(task) {
                    task.is_completed = !task.is_completed;
                    if (window.sbClient) await window.sbClient.from('chronos_tasks').update({ is_completed: task.is_completed }).eq('id', task.id);
                    if (task.is_completed && this.selectedTask && this.selectedTask.id === task.id) {
                        this.stopTimer();
                    }
                },

                async selectTask(task) {
                    if (this.isRunning) {
                        // 如果点击的是当前正在运行的任务，不做任何操作
                        if (this.selectedTask && this.selectedTask.id === task.id) return;

                        // 切换任务：先停止当前（必须 await，否则异步结算会置空新的 selection）
                        await this.stopTimer();
                    }

                    this.selectedTask = task;
                    this.timerSeconds = 0;
                    this.accumulatedSeconds = 0;
                    // Auto-start
                    this.toggleTimer();

                    // Optional: Scroll to timer or highlight?
                    // this.activeTab = 'tasks';
                },

                // Timer Methods
                toggleTimer() {
                    if (this.isRunning) {
                        // 暂停：记录当前已经过的时间到累计值
                        this.accumulatedSeconds += Math.floor((new Date() - this.sessionStartAt) / 1000);
                        this.timerSeconds = this.accumulatedSeconds;

                        clearInterval(this.timerInterval);
                        this.isRunning = false;
                        this.sessionStartAt = null;
                        this.persistTimerState();
                    } else {
                        // 开始/继续
                        this.sessionStartAt = new Date();
                        this.isRunning = true;
                        this.persistTimerState();

                        this.timerInterval = setInterval(() => {
                            this.refreshTimer();
                            // 每 10 秒强制刷新一次本地“黑匣子”心跳，防止崩溃丢失
                            if (this.timerSeconds % 10 === 0) this.persistTimerState();
                        }, 1000);
                    }
                },

                async stopTimer() {
                    if (this.isRunning || this.accumulatedSeconds > 0) {
                        const endedAt = new Date();
                        let duration = this.accumulatedSeconds;
                        let startedAt = this.sessionStartAt;

                        if (this.isRunning && this.sessionStartAt) {
                            duration += Math.floor((endedAt - this.sessionStartAt) / 1000);
                        } else {
                            // 如果是暂停状态下停止，startedAt 取自 sessionStartAt (如果还在) 或者根据持续时间倒推
                            startedAt = startedAt || new Date(endedAt.getTime() - duration * 1000);
                        }

                        if (duration > 0) {
                            const newLog = {
                                task_id: this.selectedTask ? this.selectedTask.id : null,
                                activity: this.selectedTask ? this.selectedTask.title : '未指定任务',
                                duration: duration,
                                started_at: startedAt.toISOString(),
                                ended_at: endedAt.toISOString()
                            };

                            if (window.sbClient) {
                                const { data } = await window.sbClient.from('chronos_logs').insert([newLog]).select();
                                if (data) this.logs.unshift(data[0]);
                            } else {
                                this.logs.unshift({ ...newLog, id: Date.now() });
                            }
                        }
                    }

                    clearInterval(this.timerInterval);
                    this.isRunning = false;
                    this.timerSeconds = 0;
                    this.accumulatedSeconds = 0;
                    this.sessionStartAt = null;
                    this.selectedTask = null;
                    this.persistTimerState();
                },

                // Logs Methods
                // Daily History Aggregation
                get dailyHistory() {
                    const groups = {};
                    this.logs.forEach(log => {
                        const date = log.started_at.split('T')[0];
                        if (!groups[date]) groups[date] = new Set();
                        groups[date].add(log.activity);
                    });

                    return Object.keys(groups)
                        .sort((a, b) => b.localeCompare(a))
                        .map(date => ({
                            date,
                            tasks: Array.from(groups[date])
                        }));
                },

                get filteredLogs() {
                    return this.logs.filter(l => l.started_at.split('T')[0] === this.filterDate);
                },

                get totalDaySeconds() {
                    return this.filteredLogs.reduce((acc, current) => acc + current.duration, 0);
                },

                async deleteLog(id) {
                    if (window.sbClient) await window.sbClient.from('chronos_logs').delete().eq('id', id);
                    this.logs = this.logs.filter(l => l.id !== id);
                },

                // UI Helpers
                formatTime(seconds) {
                    const h = Math.floor(seconds / 3600);
                    const m = Math.floor((seconds % 3600) / 60);
                    const s = seconds % 60;
                    return [h, m, s].map(v => v < 10 ? '0' + v : v).join(':');
                },

                getTimeRange(log) {
                    const s = new Date(log.started_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const e = new Date(log.ended_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    return `${s} - ${e}`;
                }
            }))
        });
    </script>
</body>

</html>